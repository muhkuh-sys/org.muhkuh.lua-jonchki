TODO
----

* The cache database (including the scans) identifies the repositories only with a short ID.
If the URL behind this ID changes, all information in the cache does not make sense any more. The result is a big mess.
Changes in the configuration should be detected somehow. The database must be invalidated.

Maybe something like this will work:
Combine all relevant parts of the configuration to a hash sum and store it in a new table. For example, the paths are relevant, but not the rescan time.
The hash is checked always at the start of the tool. If it does not match, all information connected to the ID is removed from the cache.

* Download files in parallel.
For this something like a download phase is needed.

* Measure download times and pick the fastest mirror.
Distinguish the total time for a download in 2 items:
1) the initial reaction time until the first chunk of data arrives.
2) the download time for the complete data phase.

* Dump the complete Resolv Tree to the report.
This is neccessary to examine error situations.

The dump should happen at the end of the jonchki_core function regardless of the result in tResult.
The representation in the report should be something like this:

  a.b.c
    v1.2.3: blocked
      dependency group 0:
        d.e.f:
          v4.5.6: blocked
            sha sum does not match
          v4.5.7: ok
        g.h.i:
          v2.3.4: blocked





* Cache max size einhalten
  Immer nach neuem Artifact oder Configuration testen.

* Orphaned Files finden und löschen
Wie: walk über alle files
 Name = "cache.sqlite3" -> OK
 Name in DB (Artifact, *hash, Configuration, *hash) -> OK
 Sonst nicht OK und weg
Wann: Beim kompletten rebuild der DB und wenn ein Fehler festgestellt wurde (z.B. Hash error)

* Bei Fehler Eintrag aus der DB schmeißen

* Artifact mit luaarchive entpacken -> mehrere Formate möglich, z.B. .tar.xz

* luaarchive im Installer bereitstellen, um Archive erstellen zu können

* Hash im Installer erreichbar machen, um .hash Files erstellen zu können

* Add a link to the parent object in the resolve table. This is important for good error messages about one instance.
Example:
Error xyz in group/artifact/version required by
 G/A/V ->
   G/A/V ->
     G/A/V

* Recognize artifacts which were already processed before and do not resolve them again.
Be careful to create something which will also work with other resolvers than "exact".

* Store error messages or warnings for any resolve operations in the GA->V table.

* Store error messages for the resolve process in the resolve table.


INSTALLER
---------

Make Jonchki build packages of itself. This is possible by using system components for downloading, archive handling, XML and database access. Pure LUA libraries are just part of the repository.
The system components can be installed on a standard Ubuntu >=14.04 with...

  apt-get install --assume-yes lua5.1 lua-filesystem lua-expat lua-sql-sqlite3 lua51-mhash lua-sql-sqlite3

Please note that lua51-mhash is available here: https://build.opensuse.org/package/show/home:doc_bacardi/lua51-mhash
Maybe we should add a system replacement for lua51-mhash if it is not available. Possible candidates would be "sha1sum" and friends.


DONE
----

* Compare the group, module, artifact and version of a new artifact configuration with the expected values.
This prevents strange errors in several cases:
1) The artifact configuration is wrong. This might happen for new aritfacts.
2) The group, module or artifact name of an aritfact changed. This happened with the luasql module, which had the group "com.github.keplerproject.lua" and was renamed to "com.github.keplerproject" later.
Services like GitHub provide a redirect from the old name to the new one. An old Jonchki configuration still had the old group name, but got the new configuration over the GitHub redirect.

* Write the report even when an error occurs.

* If an artifact is present multiple times in the dependency tree, the version scan is executed each time.
It should be executed only once instead.

* Hash in .hash Datei speichern. Da stehen 1 oder mehrere Zeilen drin, die die folgende Form haben:
   <HASH_ID>:<HASH>
  z.B.
   SHA1:0123456...
   SHA384:0123456...

* Change the Logger to a ReportWriter. This should produce something like the IVY report file.

* Better linking for the report.
The report is currently building the tree of artifacts with the "id" and "parentID" attributes.
This is no longer working since double artifacts are just references to existing ones.
One artifact can have multiple parents.
